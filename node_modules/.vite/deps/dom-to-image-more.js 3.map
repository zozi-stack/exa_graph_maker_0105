{
  "version": 3,
  "sources": ["../../dom-to-image-more/src/dom-to-image-more.js"],
  "sourcesContent": ["(function (global) {\n    'use strict';\n\n    const util = newUtil();\n    const inliner = newInliner();\n    const fontFaces = newFontFaces();\n    const images = newImages();\n\n    // Default impl options\n    const defaultOptions = {\n        // Default is to copy default styles of elements\n        copyDefaultStyles: true,\n        // Default is to fail on error, no placeholder\n        imagePlaceholder: undefined,\n        // Default cache bust is false, it will use the cache\n        cacheBust: false,\n        // Use (existing) authentication credentials for external URIs (CORS requests)\n        useCredentials: false,\n        // Use (existing) authentication credentials for external URIs (CORS requests) on some filtered requests only\n        useCredentialsFilters: [],\n        // Default resolve timeout\n        httpTimeout: 30000,\n        // Style computation cache tag rules (options are strict, relaxed)\n        styleCaching: 'strict',\n        // Default cors config is to request the image address directly\n        corsImg: undefined,\n        // Callback for adjustClonedNode eventing (to allow adjusting clone's properties)\n        adjustClonedNode: undefined,\n        // Callback to filter style properties to be included in the output\n        filterStyles: undefined,\n    };\n\n    const domtoimage = {\n        toSvg: toSvg,\n        toPng: toPng,\n        toJpeg: toJpeg,\n        toBlob: toBlob,\n        toPixelData: toPixelData,\n        toCanvas: toCanvas,\n        impl: {\n            fontFaces: fontFaces,\n            images: images,\n            util: util,\n            inliner: inliner,\n            urlCache: [],\n            options: {},\n            copyOptions: copyOptions\n        },\n    };\n\n    if (typeof exports === 'object' && typeof module === 'object') {\n        module.exports = domtoimage; // eslint-disable-line no-undef\n    } else {\n        global.domtoimage = domtoimage;\n    }\n\n    // support node and browsers\n    const ELEMENT_NODE =\n        ( Node === undefined ? undefined : Node.ELEMENT_NODE) || 1;\n    const getComputedStyle =\n        ( global === undefined ? undefined : global.getComputedStyle) ||\n        ( window === undefined ? undefined : window.getComputedStyle) ||\n        globalThis.getComputedStyle;\n    const atob =\n        ( global === undefined ? undefined : global.atob) ||\n        ( window === undefined ? undefined : window.atob) ||\n        globalThis.atob;\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options\n     * @param {Function} options.filter - Should return true if passed node should be included in the output\n     *          (excluding node means excluding it's children as well). Not called on the root node.\n     * @param {Function} options.onclone - Callback function which is called when the Document has been cloned for\n     *         rendering, can be used to modify the contents that will be rendered without affecting the original\n     *         source document.\n     * @param {String} options.bgcolor - color for the background, any valid CSS color value.\n     * @param {Number} options.width - width to be applied to node before rendering.\n     * @param {Number} options.height - height to be applied to node before rendering.\n     * @param {Object} options.style - an object whose properties to be copied to node's style before rendering.\n     * @param {Number} options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only),\n                defaults to 1.0.\n     * @param {Number} options.scale - a Number multiplier to scale up the canvas before rendering to reduce fuzzy images, defaults to 1.0.\n     * @param {String} options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch\n     * @param {Boolean} options.cacheBust - set to true to cache bust by appending the time to the request url\n     * @param {String} options.styleCaching - set to 'strict', 'relaxed' to select style caching rules\n     * @param {Boolean} options.copyDefaultStyles - set to false to disable use of default styles of elements\n     * @param {Boolean} options.disableEmbedFonts - set to true to disable font embedding into the SVG output.\n     * @param {Boolean} options.disableInlineImages - set to true to disable inlining images into the SVG output.\n     * @param {Object} options.corsImg - When the image is restricted by the server from cross-domain requests, the proxy address is passed in to get the image\n     *         - @param {String} url - eg: https://cors-anywhere.herokuapp.com/\n     *         - @param {Enumerator} method - get, post\n     *         - @param {Object} headers - eg: { \"Content-Type\", \"application/json;charset=UTF-8\" }\n     *         - @param {Object} data - post payload\n     * @param {Function} options.adjustClonedNode - callback for adjustClonedNode eventing (to allow adjusting clone's properties)\n     * @param {Function} options.filterStyles - Should return true if passed propertyName should be included in the output\n     * @return {Promise} - A promise that is fulfilled with a SVG image data URL\n     * */\n    function toSvg(node, options) {\n        const ownerWindow = domtoimage.impl.util.getWindow(node);\n        options = options || {};\n        domtoimage.impl.copyOptions(options);\n        const restorations = [];\n\n        return Promise.resolve(node)\n            .then(ensureElement)\n            .then(function (clonee) {\n                return cloneNode(clonee, options, null, ownerWindow);\n            })\n            .then(options.disableEmbedFonts ? Promise.resolve(node) : embedFonts)\n            .then(options.disableInlineImages ? Promise.resolve(node) : inlineImages)\n            .then(applyOptions)\n            .then(makeSvgDataUri)\n            .then(restoreWrappers)\n            .then(clearCache);\n\n        function ensureElement(node) {\n            if (node.nodeType === ELEMENT_NODE) return node;\n\n            const originalChild = node;\n            const wrappingSpan = document.createElement('span');\n            originalChild.replaceWith(wrappingSpan);\n            wrappingSpan.append(node);\n            restorations.push({\n                child: originalChild,\n                wrapper: wrappingSpan,\n            });\n            return wrappingSpan;\n        }\n\n        function restoreWrappers(result) {\n            // put the original children back where the wrappers were inserted\n            while (restorations.length > 0) {\n                const restoration = restorations.pop();\n                restoration.wrapper.replaceWith(restoration.child);\n            }\n\n            return result;\n        }\n\n        function clearCache(result) {\n            domtoimage.impl.urlCache = [];\n            removeSandbox();\n            return result;\n        }\n\n        function applyOptions(clone) {\n            if (options.bgcolor) {\n                clone.style.backgroundColor = options.bgcolor;\n            }\n            if (options.width) {\n                clone.style.width = `${options.width}px`;\n            }\n            if (options.height) {\n                clone.style.height = `${options.height}px`;\n            }\n            if (options.style) {\n                Object.keys(options.style).forEach(function (property) {\n                    clone.style[property] = options.style[property];\n                });\n            }\n\n            let onCloneResult = null;\n\n            if (typeof options.onclone === 'function') {\n                onCloneResult = options.onclone(clone);\n            }\n\n            return Promise.resolve(onCloneResult).then(function () {\n                return clone;\n            });\n        }\n\n        function makeSvgDataUri(clone) {\n            const width = options.width || util.width(node);\n            const height = options.height || util.height(node);\n\n            return Promise.resolve(clone)\n                .then(function (svg) {\n                    svg.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n                    return new XMLSerializer().serializeToString(svg);\n                })\n                .then(util.escapeXhtml)\n                .then(function (xhtml) {\n                    const foreignObjectSizing =\n                        (util.isDimensionMissing(width)\n                            ? ' width=\"100%\"'\n                            : ` width=\"${width}\"`) +\n                        (util.isDimensionMissing(height)\n                            ? ' height=\"100%\"'\n                            : ` height=\"${height}\"`);\n                    const svgSizing =\n                        (util.isDimensionMissing(width) ? '' : ` width=\"${width}\"`) +\n                        (util.isDimensionMissing(height) ? '' : ` height=\"${height}\"`);\n                    return `<svg xmlns=\"http://www.w3.org/2000/svg\"${svgSizing}><foreignObject${foreignObjectSizing}>${xhtml}</foreignObject></svg>`;\n                })\n                .then(function (svg) {\n                    return `data:image/svg+xml;charset=utf-8,${svg}`;\n                });\n        }\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.\n     * */\n    function toPixelData(node, options) {\n        return draw(node, options).then(function (canvas) {\n            return canvas\n                .getContext('2d')\n                .getImageData(0, 0, util.width(node), util.height(node)).data;\n        });\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a PNG image data URL\n     * */\n    function toPng(node, options) {\n        return draw(node, options).then(function (canvas) {\n            return canvas.toDataURL();\n        });\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a JPEG image data URL\n     * */\n    function toJpeg(node, options) {\n        return draw(node, options).then(function (canvas) {\n            return canvas.toDataURL(\n                'image/jpeg',\n                (options ? options.quality : undefined) || 1.0\n            );\n        });\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a PNG image blob\n     * */\n    function toBlob(node, options) {\n        return draw(node, options).then(util.canvasToBlob);\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a canvas object\n     * */\n    function toCanvas(node, options) {\n        return draw(node, options);\n    }\n\n    function copyOptions(options) {\n        // Copy options to impl options for use in impl\n        if (options.copyDefaultStyles === undefined) {\n            domtoimage.impl.options.copyDefaultStyles = defaultOptions.copyDefaultStyles;\n        } else {\n            domtoimage.impl.options.copyDefaultStyles = options.copyDefaultStyles;\n        }\n\n        if (options.imagePlaceholder === undefined) {\n            domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;\n        } else {\n            domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;\n        }\n\n        if (options.cacheBust === undefined) {\n            domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;\n        } else {\n            domtoimage.impl.options.cacheBust = options.cacheBust;\n        }\n\n        if (options.corsImg === undefined) {\n            domtoimage.impl.options.corsImg = defaultOptions.corsImg;\n        } else {\n            domtoimage.impl.options.corsImg = options.corsImg;\n        }\n\n        if (options.useCredentials === undefined) {\n            domtoimage.impl.options.useCredentials = defaultOptions.useCredentials;\n        } else {\n            domtoimage.impl.options.useCredentials = options.useCredentials;\n        }\n\n        if (options.useCredentialsFilters === undefined) {\n            domtoimage.impl.options.useCredentialsFilters =\n                defaultOptions.useCredentialsFilters;\n        } else {\n            domtoimage.impl.options.useCredentialsFilters = options.useCredentialsFilters;\n        }\n\n        if (options.httpTimeout === undefined) {\n            domtoimage.impl.options.httpTimeout = defaultOptions.httpTimeout;\n        } else {\n            domtoimage.impl.options.httpTimeout = options.httpTimeout;\n        }\n\n        if (options.styleCaching === undefined) {\n            domtoimage.impl.options.styleCaching = defaultOptions.styleCaching;\n        } else {\n            domtoimage.impl.options.styleCaching = options.styleCaching;\n        }\n    }\n\n    function draw(domNode, options) {\n        options = options || {};\n        return toSvg(domNode, options)\n            .then(util.makeImage)\n            .then(function (image) {\n                const scale = typeof options.scale !== 'number' ? 1 : options.scale;\n                const canvas = newCanvas(domNode, scale);\n                const ctx = canvas.getContext('2d');\n                ctx.msImageSmoothingEnabled = false;\n                ctx.imageSmoothingEnabled = false;\n                if (image) {\n                    ctx.scale(scale, scale);\n                    ctx.drawImage(image, 0, 0);\n                }\n                return canvas;\n            });\n\n        function newCanvas(node, scale) {\n            let width = options.width || util.width(node);\n            let height = options.height || util.height(node);\n\n            // per https://www.w3.org/TR/CSS2/visudet.html#inline-replaced-width the default width should be 300px if height\n            // not set, otherwise should be 2:1 aspect ratio for whatever height is specified\n            if (util.isDimensionMissing(width)) {\n                width = util.isDimensionMissing(height) ? 300 : height * 2.0;\n            }\n\n            if (util.isDimensionMissing(height)) {\n                height = width / 2.0;\n            }\n\n            const canvas = document.createElement('canvas');\n            canvas.width = width * scale;\n            canvas.height = height * scale;\n\n            if (options.bgcolor) {\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = options.bgcolor;\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            }\n\n            return canvas;\n        }\n    }\n\n    let sandbox = null;\n\n    function cloneNode(node, options, parentComputedStyles, ownerWindow) {\n        const filter = options.filter;\n        if (\n            node === sandbox ||\n            util.isHTMLScriptElement(node) ||\n            util.isHTMLStyleElement(node) ||\n            util.isHTMLLinkElement(node) ||\n            (parentComputedStyles !== null && filter && !filter(node))\n        ) {\n            return Promise.resolve();\n        }\n\n        return Promise.resolve(node)\n            .then(makeNodeCopy)\n            .then(adjustCloneBefore)\n            .then(function (clone) {\n                return cloneChildren(clone, getParentOfChildren(node));\n            })\n            .then(adjustCloneAfter)\n            .then(function (clone) {\n                return processClone(clone, node);\n            });\n\n        function makeNodeCopy(original) {\n            if (util.isHTMLCanvasElement(original)) {\n                return util.makeImage(original.toDataURL());\n            }\n            return original.cloneNode(false);\n        }\n\n        function adjustCloneBefore(clone) {\n            if (options.adjustClonedNode) {\n                options.adjustClonedNode(node, clone, false);\n            }\n            return Promise.resolve(clone);\n        }\n\n        function adjustCloneAfter(clone) {\n            if (options.adjustClonedNode) {\n                options.adjustClonedNode(node, clone, true);\n            }\n            return Promise.resolve(clone);\n        }\n\n        function getParentOfChildren(original) {\n            if (util.isElementHostForOpenShadowRoot(original)) {\n                return original.shadowRoot; // jump \"down\" to #shadow-root\n            }\n            return original;\n        }\n\n        function cloneChildren(clone, original) {\n            const originalChildren = getRenderedChildren(original);\n            let done = Promise.resolve();\n\n            if (originalChildren.length !== 0) {\n                const originalComputedStyles = getComputedStyle(\n                    getRenderedParent(original)\n                );\n\n                util.asArray(originalChildren).forEach(function (originalChild) {\n                    done = done.then(function () {\n                        return cloneNode(\n                            originalChild,\n                            options,\n                            originalComputedStyles,\n                            ownerWindow\n                        ).then(function (clonedChild) {\n                            if (clonedChild) {\n                                clone.appendChild(clonedChild);\n                            }\n                        });\n                    });\n                });\n            }\n\n            return done.then(function () {\n                return clone;\n            });\n\n            function getRenderedParent(original) {\n                if (util.isShadowRoot(original)) {\n                    return original.host; // jump up from #shadow-root to its parent <element>\n                }\n                return original;\n            }\n\n            function getRenderedChildren(original) {\n                if (util.isShadowSlotElement(original)) {\n                    const assignedNodes = original.assignedNodes();\n\n                    if (assignedNodes && assignedNodes.length > 0) return assignedNodes; // shadow DOM <slot> has \"assigned nodes\" as rendered children\n                }\n                return original.childNodes;\n            }\n        }\n\n        function processClone(clone, original) {\n            if (!util.isElement(clone) || util.isShadowSlotElement(original)) {\n                return Promise.resolve(clone);\n            }\n\n            return Promise.resolve()\n                .then(cloneStyle)\n                .then(clonePseudoElements)\n                .then(copyUserInput)\n                .then(fixSvg)\n                .then(fixResponsiveImages)\n                .then(function () {\n                    return clone;\n                });\n\n            function fixResponsiveImages() {\n                if (util.isHTMLImageElement(clone))\n                {\n                    // Remove lazy-loading and responsive attributes\n                    clone.removeAttribute('loading');\n\n                    // If the original had srcset or sizes, set src to the resolved image\n                    if (original.srcset || original.sizes) {\n                        clone.removeAttribute('srcset');\n                        clone.removeAttribute('sizes');\n\n                        // Use currentSrc if available, otherwise fallback to src\n                        clone.src = original.currentSrc || original.src;\n                    }\n                }\n            }\n\n            function cloneStyle() {\n                copyStyle(original, clone);\n\n                function copyFont(source, target) {\n                    target.font = source.font;\n                    target.fontFamily = source.fontFamily;\n                    target.fontFeatureSettings = source.fontFeatureSettings;\n                    target.fontKerning = source.fontKerning;\n                    target.fontSize = source.fontSize;\n                    target.fontStretch = source.fontStretch;\n                    target.fontStyle = source.fontStyle;\n                    target.fontVariant = source.fontVariant;\n                    target.fontVariantCaps = source.fontVariantCaps;\n                    target.fontVariantEastAsian = source.fontVariantEastAsian;\n                    target.fontVariantLigatures = source.fontVariantLigatures;\n                    target.fontVariantNumeric = source.fontVariantNumeric;\n                    target.fontVariationSettings = source.fontVariationSettings;\n                    target.fontWeight = source.fontWeight;\n                }\n\n                function copyStyle(sourceElement, targetElement) {\n                    const sourceComputedStyles = getComputedStyle(sourceElement);\n                    if (sourceComputedStyles.cssText) {\n                        targetElement.style.cssText = sourceComputedStyles.cssText;\n                        copyFont(sourceComputedStyles, targetElement.style); // here we re-assign the font props.\n                    } else {\n                        copyUserComputedStyleFast(\n                            options,\n                            sourceElement,\n                            sourceComputedStyles,\n                            parentComputedStyles,\n                            targetElement\n                        );\n\n                        // Remove positioning of initial element, which stops them from being captured correctly\n                        if (parentComputedStyles === null) {\n                            [\n                                'inset-block',\n                                'inset-block-start',\n                                'inset-block-end',\n                            ].forEach((prop) => targetElement.style.removeProperty(prop));\n                            ['left', 'right', 'top', 'bottom'].forEach((prop) => {\n                                if (targetElement.style.getPropertyValue(prop)) {\n                                    targetElement.style.setProperty(prop, '0px');\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n\n            function clonePseudoElements() {\n                const cloneClassName = util.uid();\n\n                [':before', ':after'].forEach(function (element) {\n                    clonePseudoElement(element);\n                });\n\n                function clonePseudoElement(element) {\n                    const style = getComputedStyle(original, element);\n                    const content = style.getPropertyValue('content');\n\n                    if (content === '' || content === 'none') {\n                        return;\n                    }\n\n                    const currentClass = clone.getAttribute('class') || '';\n                    clone.setAttribute('class', `${currentClass} ${cloneClassName}`);\n\n                    const styleElement = document.createElement('style');\n                    styleElement.appendChild(formatPseudoElementStyle());\n                    clone.appendChild(styleElement);\n\n                    function formatPseudoElementStyle() {\n                        const selector = `.${cloneClassName}:${element}`;\n                        const cssText = style.cssText\n                            ? formatCssText()\n                            : formatCssProperties();\n\n                        return document.createTextNode(`${selector}{${cssText}}`);\n\n                        function formatCssText() {\n                            return `${style.cssText} content: ${content};`;\n                        }\n\n                        function formatCssProperties() {\n                            const styleText = util\n                                .asArray(style)\n                                .map(formatProperty)\n                                .join('; ');\n                            return `${styleText};`;\n\n                            function formatProperty(name) {\n                                const propertyValue = style.getPropertyValue(name);\n                                const propertyPriority = style.getPropertyPriority(name)\n                                    ? ' !important'\n                                    : '';\n                                return `${name}: ${propertyValue}${propertyPriority}`;\n                            }\n                        }\n                    }\n                }\n            }\n\n            function copyUserInput() {\n                if (util.isHTMLTextAreaElement(original)) {\n                    clone.innerHTML = original.value;\n                }\n                if (util.isHTMLInputElement(original)) {\n                    clone.setAttribute('value', original.value);\n                }\n            }\n\n            function fixSvg() {\n                if (util.isSVGElement(clone)) {\n                    clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n\n                    if (util.isSVGRectElement(clone)) {\n                        ['width', 'height'].forEach(function (attribute) {\n                            const value = clone.getAttribute(attribute);\n                            if (value) {\n                                clone.style.setProperty(attribute, value);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    function embedFonts(node) {\n        return fontFaces.resolveAll().then(function (cssText) {\n            if (cssText !== '') {\n                const styleNode = document.createElement('style');\n                node.appendChild(styleNode);\n                styleNode.appendChild(document.createTextNode(cssText));\n            }\n            return node;\n        });\n    }\n\n    function inlineImages(node) {\n        return images.inlineAll(node).then(function () {\n            return node;\n        });\n    }\n\n    function newUtil() {\n        let uid_index = 0;\n\n        return {\n            escape: escapeRegEx,\n            isDataUrl: isDataUrl,\n            canvasToBlob: canvasToBlob,\n            resolveUrl: resolveUrl,\n            getAndEncode: getAndEncode,\n            uid: uid,\n            asArray: asArray,\n            escapeXhtml: escapeXhtml,\n            makeImage: makeImage,\n            width: width,\n            height: height,\n            getWindow: getWindow,\n            isElement: isElement,\n            isElementHostForOpenShadowRoot: isElementHostForOpenShadowRoot,\n            isShadowRoot: isShadowRoot,\n            isInShadowRoot: isInShadowRoot,\n            isHTMLElement: isHTMLElement,\n            isHTMLCanvasElement: isHTMLCanvasElement,\n            isHTMLInputElement: isHTMLInputElement,\n            isHTMLImageElement: isHTMLImageElement,\n            isHTMLLinkElement: isHTMLLinkElement,\n            isHTMLScriptElement: isHTMLScriptElement,\n            isHTMLStyleElement: isHTMLStyleElement,\n            isHTMLTextAreaElement: isHTMLTextAreaElement,\n            isShadowSlotElement: isShadowSlotElement,\n            isSVGElement: isSVGElement,\n            isSVGRectElement: isSVGRectElement,\n            isDimensionMissing: isDimensionMissing,\n        };\n\n        function getWindow(node) {\n            const ownerDocument = node ? node.ownerDocument : undefined;\n            return (\n                (ownerDocument ? ownerDocument.defaultView : undefined) ||\n                window ||\n                global\n            );\n        }\n\n        function isElementHostForOpenShadowRoot(value) {\n            return isElement(value) && value.shadowRoot !== null;\n        }\n\n        function isShadowRoot(value) {\n            return value instanceof getWindow(value).ShadowRoot;\n        }\n\n        function isInShadowRoot(value) {\n            // not calling the method, getting the method\n            if (value === null || value === undefined || value.getRootNode === undefined)\n                return false;\n            return isShadowRoot(value.getRootNode());\n        }\n\n        function isElement(value) {\n            return value instanceof getWindow(value).Element;\n        }\n\n        function isHTMLCanvasElement(value) {\n            return value instanceof getWindow(value).HTMLCanvasElement;\n        }\n\n        function isHTMLElement(value) {\n            return value instanceof getWindow(value).HTMLElement;\n        }\n\n        function isHTMLImageElement(value) {\n            return value instanceof getWindow(value).HTMLImageElement;\n        }\n\n        function isHTMLInputElement(value) {\n            return value instanceof getWindow(value).HTMLInputElement;\n        }\n\n        function isHTMLLinkElement(value) {\n            return value instanceof getWindow(value).HTMLLinkElement;\n        }\n\n        function isHTMLScriptElement(value) {\n            return value instanceof getWindow(value).HTMLScriptElement;\n        }\n\n        function isHTMLStyleElement(value) {\n            return value instanceof getWindow(value).HTMLStyleElement;\n        }\n\n        function isHTMLTextAreaElement(value) {\n            return value instanceof getWindow(value).HTMLTextAreaElement;\n        }\n\n        function isShadowSlotElement(value) {\n            return (\n                isInShadowRoot(value) && value instanceof getWindow(value).HTMLSlotElement\n            );\n        }\n\n        function isSVGElement(value) {\n            return value instanceof getWindow(value).SVGElement;\n        }\n\n        function isSVGRectElement(value) {\n            return value instanceof getWindow(value).SVGRectElement;\n        }\n\n        function isDataUrl(url) {\n            return url.search(/^(data:)/) !== -1;\n        }\n\n        function isDimensionMissing(value) {\n            return isNaN(value) || value <= 0;\n        }\n\n        function asBlob(canvas) {\n            return new Promise(function (resolve) {\n                const binaryString = atob(canvas.toDataURL().split(',')[1]);\n                const length = binaryString.length;\n                const binaryArray = new Uint8Array(length);\n\n                for (let i = 0; i < length; i++) {\n                    binaryArray[i] = binaryString.charCodeAt(i);\n                }\n\n                resolve(\n                    new Blob([binaryArray], {\n                        type: 'image/png',\n                    })\n                );\n            });\n        }\n\n        function canvasToBlob(canvas) {\n            if (canvas.toBlob) {\n                return new Promise(function (resolve) {\n                    canvas.toBlob(resolve);\n                });\n            }\n\n            return asBlob(canvas);\n        }\n\n        function resolveUrl(url, baseUrl) {\n            const doc = document.implementation.createHTMLDocument();\n            const base = doc.createElement('base');\n            doc.head.appendChild(base);\n            const a = doc.createElement('a');\n            doc.body.appendChild(a);\n            base.href = baseUrl;\n            a.href = url;\n            return a.href;\n        }\n\n        function uid() {\n            return `u${fourRandomChars()}${uid_index++}`;\n\n            function fourRandomChars() {\n                /* see https://stackoverflow.com/a/6248722/2519373 */\n                return `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(\n                    36\n                )}`.slice(-4);\n            }\n        }\n\n        function makeImage(uri) {\n            if (uri === 'data:,') {\n                return Promise.resolve();\n            }\n\n            return new Promise(function (resolve, reject) {\n                // Create an SVG element to house the image\n                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n                // and create the Image element to insert into that wrapper\n                const image = new Image();\n\n                if (domtoimage.impl.options.useCredentials) {\n                    image.crossOrigin = 'use-credentials';\n                }\n\n                image.onload = function () {\n                    // Cleanup: remove theimage from the document\n                    document.body.removeChild(svg);\n\n                    if (window && window.requestAnimationFrame) {\n                        // In order to work around a Firefox bug (webcompat/web-bugs#119834) we\n                        // need to wait one extra frame before it's safe to read the image data.\n                        window.requestAnimationFrame(function () {\n                            resolve(image);\n                        });\n                    } else {\n                        // If we don't have a window or requestAnimationFrame function proceed immediately.\n                        resolve(image);\n                    }\n                };\n\n                image.onerror = (error) => {\n                    // Cleanup: remove the image from the document\n                    document.body.removeChild(svg);\n\n                    reject(error);\n                };\n\n                svg.appendChild(image);\n                image.src = uri;\n\n                // Add the SVG to the document body (invisible)\n                document.body.appendChild(svg);\n            });\n        }\n\n        function getAndEncode(url) {\n            let cacheEntry = domtoimage.impl.urlCache.find(function (el) {\n                return el.url === url;\n            });\n\n            if (!cacheEntry) {\n                cacheEntry = {\n                    url: url,\n                    promise: null,\n                };\n                domtoimage.impl.urlCache.push(cacheEntry);\n            }\n\n            if (cacheEntry.promise === null) {\n                if (domtoimage.impl.options.cacheBust) {\n                    // Cache bypass so we don't have CORS issues with cached images\n                    // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n                    url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n                }\n\n                cacheEntry.promise = new Promise(function (resolve) {\n                    const xhr = new XMLHttpRequest();\n                    xhr.timeout = domtoimage.impl.options.httpTimeout;\n                    xhr.onerror = placehold;\n                    xhr.ontimeout = placehold;\n                    xhr.onloadend = function () {\n                        if (xhr.readyState === XMLHttpRequest.DONE) {\n                            const status = xhr.status;\n                            // In local files, status is 0 upon success in Mozilla Firefox\n                            if (\n                                (status === 0 && url.toLowerCase().startsWith('file://')) ||\n                                (status >= 200 && status <= 300 && xhr.response !== null)\n                            ) {\n                                const response = xhr.response;\n                                if (!(response instanceof Blob)) {\n                                    fail(\n                                        'Expected response to be a Blob, but got: ' +\n                                            typeof response\n                                    );\n                                }\n                                const reader = new FileReader();\n                                reader.onloadend = function () {\n                                    const result = reader.result;\n                                    resolve(result);\n                                };\n                                try {\n                                    reader.readAsDataURL(response);\n                                } catch (ex) {\n                                    fail(\n                                        'Failed to read the response as Data URL: ' +\n                                            ex.toString()\n                                    );\n                                }\n                            } else {\n                                placehold();\n                            }\n                        }\n                    };\n\n                    function fail(message) {\n                        console.error(message);\n                        resolve('');\n                    }\n\n                    function placehold() {\n                        const placeholder = domtoimage.impl.options.imagePlaceholder;\n\n                        if (placeholder) {\n                            resolve(placeholder);\n                        } else {\n                            fail('Status:' + xhr.status + ' while fetching resource: ' + url);\n                        }\n                    }\n\n                    function handleJson(data) {\n                        try {\n                            return JSON.parse(JSON.stringify(data));\n                        } catch (e) {\n                            fail('corsImg.data is missing or invalid:' + e.toString());\n                        }\n                    }\n\n                    if (domtoimage.impl.options.useCredentialsFilters.length > 0) {\n                        domtoimage.impl.options.useCredentials =\n                            domtoimage.impl.options.useCredentialsFilters.filter(\n                                (credentialsFilter) => url.search(credentialsFilter) >= 0\n                            ).length > 0;\n                    }\n\n                    if (domtoimage.impl.options.useCredentials) {\n                        xhr.withCredentials = true;\n                    }\n\n                    if (\n                        domtoimage.impl.options.corsImg &&\n                        url.indexOf('http') === 0 &&\n                        url.indexOf(window.location.origin) === -1\n                    ) {\n                        const method =\n                            (\n                                domtoimage.impl.options.corsImg.method || 'GET'\n                            ).toUpperCase() === 'POST'\n                                ? 'POST'\n                                : 'GET';\n                        xhr.open(\n                            method,\n                            (domtoimage.impl.options.corsImg.url || '').replace(\n                                '#{cors}',\n                                url\n                            ),\n                            true\n                        );\n\n                        let isJson = false;\n                        const headers = domtoimage.impl.options.corsImg.headers || {};\n                        Object.keys(headers).forEach(function (key) {\n                            if (headers[key].indexOf('application/json') !== -1) {\n                                isJson = true;\n                            }\n                            xhr.setRequestHeader(key, headers[key]);\n                        });\n\n                        const corsData = handleJson(\n                            domtoimage.impl.options.corsImg.data || ''\n                        );\n\n                        Object.keys(corsData).forEach(function (key) {\n                            if (typeof corsData[key] === 'string') {\n                                corsData[key] = corsData[key].replace('#{cors}', url);\n                            }\n                        });\n\n                        xhr.responseType = 'blob';\n                        xhr.send(isJson ? JSON.stringify(corsData) : corsData);\n                    } else {\n                        xhr.open('GET', url, true);\n                        xhr.responseType = 'blob';\n                        xhr.send();\n                    }\n                });\n            }\n            return cacheEntry.promise;\n        }\n\n        function escapeRegEx(string) {\n            return string.replace(/([.*+?^${}()|[\\]/\\\\])/g, '\\\\$1');\n        }\n\n        function asArray(arrayLike) {\n            const array = [];\n            const length = arrayLike.length;\n            for (let i = 0; i < length; i++) {\n                array.push(arrayLike[i]);\n            }\n\n            return array;\n        }\n\n        function escapeXhtml(string) {\n            return string.replace(/%/g, '%25').replace(/#/g, '%23').replace(/\\n/g, '%0A');\n        }\n\n        function width(node) {\n            const width = px(node, 'width');\n\n            if (!isNaN(width)) return width;\n\n            const leftBorder = px(node, 'border-left-width');\n            const rightBorder = px(node, 'border-right-width');\n            return node.scrollWidth + leftBorder + rightBorder;\n        }\n\n        function height(node) {\n            const height = px(node, 'height');\n\n            if (!isNaN(height)) return height;\n\n            const topBorder = px(node, 'border-top-width');\n            const bottomBorder = px(node, 'border-bottom-width');\n            return node.scrollHeight + topBorder + bottomBorder;\n        }\n\n        function px(node, styleProperty) {\n            if (node.nodeType === ELEMENT_NODE) {\n                let value = getComputedStyle(node).getPropertyValue(styleProperty);\n                if (value.slice(-2) === 'px') {\n                    value = value.slice(0, -2);\n                    return parseFloat(value);\n                }\n            }\n\n            return NaN;\n        }\n    }\n\n    function newInliner() {\n        const URL_REGEX = /url\\(\\s*([\"']?)((?:\\\\.|[^\\\\)])+)\\1\\s*\\)/gm;\n\n        return {\n            inlineAll: inlineAll,\n            shouldProcess: shouldProcess,\n            impl: {\n                readUrls: readUrls,\n                inline: inline,\n                urlAsRegex: urlAsRegex,\n            },\n        };\n\n        function shouldProcess(string) {\n            return string.search(URL_REGEX) !== -1;\n        }\n\n        function readUrls(string) {\n            const result = [];\n            let match;\n            while ((match = URL_REGEX.exec(string)) !== null) {\n                result.push(match[2]);\n            }\n            return result.filter(function (url) {\n                return !util.isDataUrl(url);\n            });\n        }\n\n        function urlAsRegex(urlValue) {\n            return new RegExp(`url\\\\(([\"']?)(${util.escape(urlValue)})\\\\1\\\\)`, 'gm');\n        }\n\n        function inline(string, url, baseUrl, get) {\n            return Promise.resolve(url)\n                .then(function (urlValue) {\n                    return baseUrl ? util.resolveUrl(urlValue, baseUrl) : urlValue;\n                })\n                .then(get || util.getAndEncode)\n                .then(function (dataUrl) {\n                    const pattern = urlAsRegex(url);\n                    return string.replace(pattern, `url($1${dataUrl}$1)`);\n                });\n        }\n\n        function inlineAll(string, baseUrl, get) {\n            if (nothingToInline()) {\n                return Promise.resolve(string);\n            }\n\n            return Promise.resolve(string)\n                .then(readUrls)\n                .then(function (urls) {\n                    let done = Promise.resolve(string);\n                    urls.forEach(function (url) {\n                        done = done.then(function (prefix) {\n                            return inline(prefix, url, baseUrl, get);\n                        });\n                    });\n                    return done;\n                });\n\n            function nothingToInline() {\n                return !shouldProcess(string);\n            }\n        }\n    }\n\n    function newFontFaces() {\n        return {\n            resolveAll: resolveAll,\n            impl: {\n                readAll: readAll,\n            },\n        };\n\n        function resolveAll() {\n            return readAll()\n                .then(function (webFonts) {\n                    return Promise.all(\n                        webFonts.map(function (webFont) {\n                            return webFont.resolve();\n                        })\n                    );\n                })\n                .then(function (cssStrings) {\n                    return cssStrings.join('\\n');\n                });\n        }\n\n        function readAll() {\n            return Promise.resolve(util.asArray(document.styleSheets))\n                .then(getCssRules)\n                .then(selectWebFontRules)\n                .then(function (rules) {\n                    return rules.map(newWebFont);\n                });\n\n            function selectWebFontRules(cssRules) {\n                return cssRules\n                    .filter(function (rule) {\n                        return rule.type === CSSRule.FONT_FACE_RULE;\n                    })\n                    .filter(function (rule) {\n                        return inliner.shouldProcess(rule.style.getPropertyValue('src'));\n                    });\n            }\n\n            function getCssRules(styleSheets) {\n                const cssRules = [];\n                styleSheets.forEach(function (sheet) {\n                    const sheetProto = Object.getPrototypeOf(sheet);\n                    // NOSONAR\n                    if (Object.prototype.hasOwnProperty.call(sheetProto, 'cssRules')) {\n                        try {\n                            util.asArray(sheet.cssRules || []).forEach(\n                                cssRules.push.bind(cssRules)\n                            );\n                        } catch (e) {\n                            console.error(\n                                'domtoimage: Error while reading CSS rules from: ' +\n                                    sheet.href,\n                                e.toString()\n                            );\n                        }\n                    }\n                });\n                return cssRules;\n            }\n\n            function newWebFont(webFontRule) {\n                return {\n                    resolve: function resolve() {\n                        // NOSONAR\n                        const baseUrl = (webFontRule.parentStyleSheet || {}).href;\n                        return inliner.inlineAll(webFontRule.cssText, baseUrl);\n                    },\n                    src: function () {\n                        return webFontRule.style.getPropertyValue('src');\n                    },\n                };\n            }\n        }\n    }\n\n    function newImages() {\n        return {\n            inlineAll: inlineAll,\n            impl: {\n                newImage: newImage,\n            },\n        };\n\n        function newImage(element) {\n            return {\n                inline: inline,\n            };\n\n            function inline(get) {\n                if (util.isDataUrl(element.src)) {\n                    return Promise.resolve();\n                }\n\n                return Promise.resolve(element.src)\n                    .then(get || util.getAndEncode)\n                    .then(function (dataUrl) {\n                        return new Promise(function (resolve) {\n                            element.onload = resolve;\n                            // for any image with invalid src(such as <img src />), just ignore it\n                            element.onerror = resolve;\n                            element.src = dataUrl;\n                        });\n                    });\n            }\n        }\n\n        function inlineAll(node) {\n            if (!util.isElement(node)) {\n                return Promise.resolve(node);\n            }\n\n            return inlineCSSProperty(node).then(function () {\n                if (util.isHTMLImageElement(node)) {\n                    return newImage(node).inline();\n                } else {\n                    return Promise.all(\n                        util.asArray(node.childNodes).map(function (child) {\n                            return inlineAll(child);\n                        })\n                    );\n                }\n            });\n\n            function inlineCSSProperty(node) {\n                const properties = ['background', 'background-image'];\n\n                const inliningTasks = properties.map(function (propertyName) {\n                    const value = node.style.getPropertyValue(propertyName);\n                    const priority = node.style.getPropertyPriority(propertyName);\n\n                    if (!value) {\n                        return Promise.resolve();\n                    }\n\n                    return inliner.inlineAll(value).then(function (inlinedValue) {\n                        node.style.setProperty(propertyName, inlinedValue, priority);\n                    });\n                });\n\n                return Promise.all(inliningTasks).then(function () {\n                    return node;\n                });\n            }\n        }\n    }\n\n    function setStyleProperty(targetStyle, name, value, priority) {\n        const needs_prefixing = ['background-clip'].indexOf(name) >= 0;\n        if (priority) {\n            targetStyle.setProperty(name, value, priority);\n            if (needs_prefixing) {\n                targetStyle.setProperty(`-webkit-${name}`, value, priority);\n            }\n        } else {\n            targetStyle.setProperty(name, value);\n            if (needs_prefixing) {\n                targetStyle.setProperty(`-webkit-${name}`, value);\n            }\n        }\n    }\n\n    function copyUserComputedStyleFast(\n        options,\n        sourceElement,\n        sourceComputedStyles,\n        parentComputedStyles,\n        targetElement\n    ) {\n        const defaultStyle = domtoimage.impl.options.copyDefaultStyles\n            ? getDefaultStyle(options, sourceElement)\n            : {};\n        const targetStyle = targetElement.style;\n\n        util.asArray(sourceComputedStyles).forEach(function (name) {\n            if (options.filterStyles) {\n                if (!options.filterStyles(sourceElement, name)) {\n                    return;\n                }\n            }\n\n            const sourceValue = sourceComputedStyles.getPropertyValue(name);\n            const defaultValue = defaultStyle[name];\n            const parentValue = parentComputedStyles\n                ? parentComputedStyles.getPropertyValue(name)\n                : undefined;\n\n            // Ignore setting style property on clone node, if already it has a style (through adjustCloneNode)\n            const targetValue = targetStyle.getPropertyValue(name);\n            if (targetValue) return;\n\n            // If the style does not match the default, or it does not match the parent's, set it. We don't know which\n            // styles are inherited from the parent and which aren't, so we have to always check both.\n            if (\n                sourceValue !== defaultValue ||\n                (parentComputedStyles && sourceValue !== parentValue)\n            ) {\n                const priority = sourceComputedStyles.getPropertyPriority(name);\n                setStyleProperty(targetStyle, name, sourceValue, priority);\n            }\n        });\n    }\n\n    let removeDefaultStylesTimeoutId = null;\n    let tagNameDefaultStyles = {};\n\n    const ascentStoppers = [\n        // these come from https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n        'ADDRESS',\n        'ARTICLE',\n        'ASIDE',\n        'BLOCKQUOTE',\n        'DETAILS',\n        'DIALOG',\n        'DD',\n        'DIV',\n        'DL',\n        'DT',\n        'FIELDSET',\n        'FIGCAPTION',\n        'FIGURE',\n        'FOOTER',\n        'FORM',\n        'H1',\n        'H2',\n        'H3',\n        'H4',\n        'H5',\n        'H6',\n        'HEADER',\n        'HGROUP',\n        'HR',\n        'LI',\n        'MAIN',\n        'NAV',\n        'OL',\n        'P',\n        'PRE',\n        'SECTION',\n        'SVG',\n        'TABLE',\n        'UL',\n        // this is some non-standard ones\n        'math', // intentionally lowercase, thanks Safari\n        'svg', // in case we have an svg embedded element\n        // these are ultimate stoppers in case something drastic changes in how the DOM works\n        'BODY',\n        'HEAD',\n        'HTML',\n    ];\n\n    function getDefaultStyle(options, sourceElement) {\n        const tagHierarchy = computeTagHierarchy(sourceElement);\n        const tagKey = computeTagKey(tagHierarchy);\n        if (tagNameDefaultStyles[tagKey]) {\n            return tagNameDefaultStyles[tagKey];\n        }\n\n        // We haven't cached the answer for that hierachy yet, build a\n        // sandbox (if not yet created), fill it with the hierarchy that\n        // matters, and grab the default styles associated\n        const sandboxWindow = ensureSandboxWindow();\n        const defaultElement = constructElementHierachy(\n            sandboxWindow.document,\n            tagHierarchy\n        );\n        const defaultStyle = computeStyleForDefaults(sandboxWindow, defaultElement);\n        destroyElementHierarchy(defaultElement);\n\n        tagNameDefaultStyles[tagKey] = defaultStyle;\n        return defaultStyle;\n\n        function computeTagHierarchy(sourceNode) {\n            const tagNames = [];\n\n            do {\n                if (sourceNode.nodeType === ELEMENT_NODE) {\n                    const tagName = sourceNode.tagName;\n                    tagNames.push(tagName);\n\n                    if (ascentStoppers.includes(tagName)) {\n                        break;\n                    }\n                }\n\n                sourceNode = sourceNode.parentNode;\n            } while (sourceNode);\n\n            return tagNames;\n        }\n\n        function computeTagKey(tagHierarchy) {\n            if (options.styleCaching === 'relaxed') {\n                // pick up only the ascent-stopping element tag and the element tag itself\n                /* jshint unused:true */\n                return tagHierarchy\n                    .filter((_, i, a) => i === 0 || i === a.length - 1)\n                    .join('>');\n            }\n            // for all other cases, fall back the the entire path\n            return tagHierarchy.join('>'); // it's like CSS\n        }\n\n        function constructElementHierachy(sandboxDocument, tagHierarchy) {\n            let element = sandboxDocument.body;\n            do {\n                const childTagName = tagHierarchy.pop();\n                const childElement = sandboxDocument.createElement(childTagName);\n                element.appendChild(childElement);\n                element = childElement;\n            } while (tagHierarchy.length > 0);\n\n            // Ensure that there is some content, so that properties like margin are applied.\n            // we use zero-width space to handle FireFox adding a pixel\n            element.textContent = '\\u200b';\n            return element;\n        }\n\n        function computeStyleForDefaults(sandboxWindow, defaultElement) {\n            const defaultStyle = {};\n            const defaultComputedStyle = sandboxWindow.getComputedStyle(defaultElement);\n\n            // Copy styles to an object, making sure that 'width' and 'height' are given the default value of 'auto', since\n            // their initial value is always 'auto' despite that the default computed value is sometimes an absolute length.\n            util.asArray(defaultComputedStyle).forEach(function (name) {\n                defaultStyle[name] =\n                    name === 'width' || name === 'height'\n                        ? 'auto'\n                        : defaultComputedStyle.getPropertyValue(name);\n            });\n            return defaultStyle;\n        }\n\n        function destroyElementHierarchy(element) {\n            do {\n                const parentElement = element.parentElement;\n                if (parentElement !== null) {\n                    parentElement.removeChild(element);\n                }\n                element = parentElement;\n            } while (element && element.tagName !== 'BODY');\n        }\n    }\n\n    function ensureSandboxWindow() {\n        if (sandbox) {\n            return sandbox.contentWindow;\n        }\n\n        // figure out how this document is defined (doctype and charset)\n        const charsetToUse = document.characterSet || 'UTF-8';\n        const docType = document.doctype;\n        const docTypeDeclaration = docType\n            ? `<!DOCTYPE ${escapeHTML(docType.name)} ${escapeHTML(\n                docType.publicId\n            )} ${escapeHTML(docType.systemId)}`.trim() + '>'\n            : '';\n\n        // Create a hidden sandbox <iframe> element within we can create default HTML elements and query their\n        // computed styles. Elements must be rendered in order to query their computed styles. The <iframe> won't\n        // render at all with `display: none`, so we have to use `visibility: hidden` with `position: fixed`.\n        sandbox = document.createElement('iframe');\n        sandbox.id = 'domtoimage-sandbox-' + util.uid();\n        sandbox.style.top = '-9999px';\n        sandbox.style.visibility = 'hidden';\n        sandbox.style.position = 'fixed';\n        document.body.appendChild(sandbox);\n\n        return tryTechniques(\n            sandbox,\n            docTypeDeclaration,\n            charsetToUse,\n            'domtoimage-sandbox'\n        );\n\n        function escapeHTML(unsafeText) {\n            if (unsafeText) {\n                const div = document.createElement('div');\n                div.innerText = unsafeText;\n                return div.innerHTML;\n            } else {\n                return '';\n            }\n        }\n\n        function tryTechniques(sandbox, doctype, charset, title) {\n            // try the good old-fashioned document write with all the correct attributes set\n            try {\n                sandbox.contentWindow.document.write(\n                    `${doctype}<html><head><meta charset='${charset}'><title>${title}</title></head><body></body></html>`\n                );\n                return sandbox.contentWindow;\n            } catch (_) {\n                // swallow exception and fall through to next technique\n            }\n\n            const metaCharset = document.createElement('meta');\n            metaCharset.setAttribute('charset', charset);\n\n            // let's attempt it using srcdoc, so we can still set the doctype and charset\n            try {\n                const sandboxDocument = document.implementation.createHTMLDocument(title);\n                sandboxDocument.head.appendChild(metaCharset);\n                const sandboxHTML = doctype + sandboxDocument.documentElement.outerHTML;\n                sandbox.setAttribute('srcdoc', sandboxHTML);\n                return sandbox.contentWindow;\n            } catch (_) {\n                // NOSONAR\n                // swallow exception and fall through to the simplest path\n            }\n\n            // let's attempt it using contentDocument... here we're not able to set the doctype\n            sandbox.contentDocument.head.appendChild(metaCharset);\n            sandbox.contentDocument.title = title;\n            return sandbox.contentWindow;\n        }\n    }\n\n    function removeSandbox() {\n        if (sandbox) {\n            document.body.removeChild(sandbox);\n            sandbox = null;\n        }\n\n        if (removeDefaultStylesTimeoutId) {\n            clearTimeout(removeDefaultStylesTimeoutId);\n        }\n\n        removeDefaultStylesTimeoutId = setTimeout(() => {\n            removeDefaultStylesTimeoutId = null;\n            tagNameDefaultStyles = {};\n        }, 20 * 1000);\n    }\n})(this);\n"],
  "mappings": "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",
  "names": ["global", "util", "let", "uid_index", "escape", "string", "replace", "isDataUrl", "url", "search", "canvasToBlob", "canvas", "toBlob", "Promise", "resolve", "binaryString", "atob", "toDataURL", "split", "length", "binaryArray", "Uint8Array", "i", "charCodeAt", "Blob", "type", "resolveUrl", "baseUrl", "doc", "document", "implementation", "createHTMLDocument", "base", "createElement", "a", "head", "appendChild", "body", "href", "getAndEncode", "cacheEntry", "domtoimage", "impl", "urlCache", "find", "el", "promise", "push", "options", "cacheBust", "test", "Date", "getTime", "xhr", "XMLHttpRequest", "fail", "message", "console", "error", "placehold", "placeholder", "imagePlaceholder", "status", "timeout", "httpTimeout", "onerror", "ontimeout", "onloadend", "readyState", "DONE", "toLowerCase", "startsWith", "response", "reader", "FileReader", "result", "readAsDataURL", "ex", "toString", "useCredentialsFilters", "useCredentials", "filter", "e", "credentialsFilter", "withCredentials", "corsImg", "indexOf", "window", "location", "origin", "method", "toUpperCase", "open", "isJson", "headers", "corsData", "Object", "keys", "forEach", "key", "setRequestHeader", "data", "JSON", "parse", "stringify", "responseType", "send", "uid", "Math", "random", "pow", "slice", "asArray", "arrayLike", "array", "escapeXhtml", "makeImage", "uri", "reject", "svg", "createElementNS", "image", "Image", "crossOrigin", "onload", "removeChild", "requestAnimationFrame", "src", "width", "node", "px", "isNaN", "leftBorder", "rightBorder", "scrollWidth", "height", "topBorder", "bottomBorder", "scrollHeight", "getWindow", "isElement", "isElementHostForOpenShadowRoot", "value", "shadowRoot", "isShadowRoot", "isInShadowRoot", "isHTMLElement", "HTMLElement", "isHTMLCanvasElement", "HTMLCanvasElement", "isHTMLInputElement", "HTMLInputElement", "isHTMLImageElement", "HTMLImageElement", "isHTMLLinkElement", "HTMLLinkElement", "isHTMLScriptElement", "HTMLScriptElement", "isHTMLStyleElement", "HTMLStyleElement", "isHTMLTextAreaElement", "HTMLTextAreaElement", "isShadowSlotElement", "HTMLSlotElement", "isSVGElement", "SVGElement", "isSVGRectElement", "SVGRectElement", "isDimensionMissing", "ownerDocument", "undefined", "defaultView", "ShadowRoot", "getRootNode", "Element", "styleProperty", "nodeType", "ELEMENT_NODE", "getComputedStyle", "getPropertyValue", "parseFloat", "NaN", "inliner", "URL_REGEX", "inlineAll", "get", "shouldProcess", "then", "readUrls", "urls", "done", "prefix", "inline", "urlAsRegex", "match", "exec", "urlValue", "RegExp", "dataUrl", "pattern", "fontFaces", "resolveAll", "readAll", "webFonts", "all", "map", "webFont", "cssStrings", "join", "styleSheets", "cssRules", "sheet", "sheetProto", "getPrototypeOf", "prototype", "hasOwnProperty", "call", "bind", "rule", "CSSRule", "FONT_FACE_RULE", "style", "rules", "newWebFont", "webFontRule", "parentStyleSheet", "cssText", "images", "inlineCSSProperty", "newImage", "childNodes", "child", "properties", "inliningTasks", "propertyName", "priority", "getPropertyPriority", "inlinedValue", "setProperty", "element", "defaultOptions", "copyDefaultStyles", "styleCaching", "adjustClonedNode", "filterStyles", "toSvg", "toPng", "draw", "toJpeg", "quality", "toPixelData", "getContext", "getImageData", "toCanvas", "copyOptions", "exports", "module", "Node", "globalThis", "ownerWindow", "restorations", "originalChild", "wrappingSpan", "replaceWith", "append", "wrapper", "clonee", "cloneNode", "parentComputedStyles", "sandbox", "makeNodeCopy", "adjustCloneBefore", "clone", "cloneChildren", "getParentOfChildren", "adjustCloneAfter", "processClone", "original", "originalChildren", "getRenderedChildren", "originalComputedStyles", "getRenderedParent", "clonedChild", "host", "assignedNodes", "cloneStyle", "clonePseudoElements", "copyUserInput", "fixSvg", "fixResponsiveImages", "removeAttribute", "srcset", "sizes", "currentSrc", "copyFont", "source", "target", "font", "fontFamily", "fontFeatureSettings", "fontKerning", "fontSize", "fontStretch", "fontStyle", "fontVariant", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariationSettings", "fontWeight", "copyStyle", "sourceElement", "targetElement", "sourceComputedStyles", "copyUserComputedStyleFast", "removeProperty", "prop", "cloneClassName", "clonePseudoElement", "content", "formatPseudoElementStyle", "selector", "formatCssText", "formatCssProperties", "createTextNode", "styleText", "formatProperty", "name", "propertyValue", "propertyPriority", "currentClass", "getAttribute", "styleElement", "setAttribute", "innerHTML", "attribute", "disableEmbedFonts", "embedFonts", "disableInlineImages", "inlineImages", "bgcolor", "backgroundColor", "property", "onCloneResult", "onclone", "XMLSerializer", "serializeToString", "xhtml", "foreignObjectSizing", "restoration", "pop", "removeDefaultStylesTimeoutId", "clearTimeout", "setTimeout", "tagNameDefaultStyles", "domNode", "scale", "ctx", "fillStyle", "fillRect", "msImageSmoothingEnabled", "imageSmoothingEnabled", "drawImage", "styleNode", "defaultStyle", "tagKey", "tagHierarchy", "_", "sourceNode", "tagNames", "tagName", "ascentStoppers", "includes", "parentNode", "defaultElement", "sandboxDocument", "childTagName", "childElement", "textContent", "sandboxWindow", "contentWindow", "charsetToUse", "characterSet", "docTypeDeclaration", "docType", "doctype", "escapeHTML", "publicId", "systemId", "trim", "id", "top", "visibility", "position", "tryTechniques", "charset", "title", "write", "metaCharset", "sandboxHTML", "documentElement", "outerHTML", "contentDocument", "unsafeText", "div", "innerText", "defaultComputedStyle", "destroyElementHierarchy", "parentElement", "targetStyle", "needs_prefixing", "sourceValue", "defaultValue", "parentValue", "this"]
}
